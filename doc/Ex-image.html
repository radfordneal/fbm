<html>
<body>
<pre>


EXAMPLES OF BAYESIAN NEURAL NETWORK IMAGE MODELS

One prominent application of neural network models is for the
classification of images.  Here, a fairly simple artificial example of
such an image classification problem is presented.  Several Bayesian
neural network models for this task are presented, including ones that
use convolutional connections.  Fitting such a model by simple
gradient descent is also presented.

These examples also illustrate how the training data can be divided in
several ways into a set of cases used for fitting, and a set of
validation cases, which can be used to assess performance.  Although
Bayesian methods do not require a validation set in theory, in
practice, some check on whether good performance has been achieved is
advisable before actually using predictions from a Bayesian model, to
guard against statistical mistakes, poor convergence of MCMC methods,
or, if nothing else, out-and-out bugs in the scripts or programs used.

The command files for this example are in the ex-image sub-directory.


The image classification problem used in these examples.

The program in igen.c generates artificial 6x6 monochrome images in
which one of the symbols "+", "X", "O", or "H" appears in some 3x3
patch in the image.  The classification task is to predict from the 36
pixels of an image which symbol appears in some patch in the image
(whose location could be any of the sixteen possibilities).

Generation of an image starts by randomly generating backgroup pixel
values from a Gaussian distribution with mean zero and standard
deviation one, independently for each of the 36 pixels.  A location
for a symbol is then randomly gnerated from the 16 possible positions.
(Note that the centre position of the symbol cannot be in the first or
last row, or the first or last column, leaving four possible row
positions and four possible column positions.)  The identity of the
symbol is also picked randomly from "+", "X", "O", and "H" (coded as
0, 1, 2, or 3), with each symbol having probability 1/4.  The pixels
in the 3x3 patch where the symbol is located are then replaced by
the following patterns for each symbol:

       "+"         "X"         "O"         "H"

    -1 +1 -1    +1 -1 +1    +1 +1 +1    +1 -1 +1
    +1 +1 +1    -1 +1 -1    +1 -1 +1    +1 +1 +1
    -1 +1 -1    +1 -1 +1    +1 +1 +1    +1 -1 +1

Finally, Gaussian noise with mean zero and standard deviation 0.6 is
added to all pixels, and the pixel values are rounded to three decimal
places.

When passed an argument, the igen program prints each image, with the
true location and identity of the symbol, as well as the probabilities
for each symbol that can be inferred from the pixels using the true
model of how these images are generated.  Here are three of the images
generated:
  

  Case 2, Class +(0), Centred at 1,3, PP: +0.999 X0.000 O0.001 H0.000
  
        0      1      2      3      4      5       0 1 2 3 4 5
  0   -0.626 +1.056 -0.845 +0.762 -0.477 -0.837    O # O #   O
  1   +0.723 +0.971 +1.134 +1.040 +1.059 +0.147    # # # # #
  2   -1.095 -2.091 -0.671 +0.971 -0.649 +0.715    O O O # O #
  3   +0.787 -1.511 +1.770 +1.620 +0.221 -0.582    # O # #   O
  4   +0.535 -1.675 -0.308 -0.815 -0.786 +0.273    # O   O O
  5   -0.215 +0.335 -1.835 -0.286 +1.338 +0.336        O   #
    
    
  Case 11, Class X(1), Centred at 2,4, PP: +0.157 X0.843 O0.000 H0.000
  
        0      1      2      3      4      5       0 1 2 3 4 5
  0   -0.818 +0.064 -0.260 +0.159 +0.272 +0.009    O
  1   +0.236 +1.215 -0.756 -0.263 -1.089 +1.030      # O   O #
  2   -1.443 -1.099 +0.870 -0.965 +1.381 -1.830    O O # O # O
  3   -1.044 +1.340 +0.445 +1.512 -1.571 +0.600    O #   # O #
  4   -0.776 +0.444 +1.656 -1.832 +0.346 -0.823    O   # O   O
  5   -0.431 +0.744 +1.261 +3.750 -1.659 +1.955      # # # O #
  
  
  Case 60, Class O(2), Centred at 4,1, PP: +0.000 X0.000 O0.418 H0.582
  
        0      1      2      3      4      5       0 1 2 3 4 5
  0   +1.576 -1.255 +1.379 +1.325 -0.615 +0.105    # O # # O
  1   +0.734 -0.416 -1.230 -0.001 -1.100 +0.948    #   O   O #
  2   +0.837 -1.332 +0.800 -2.698 +1.139 +0.417    # O # O #
  3   +1.236 +0.820 +1.372 -0.339 +0.924 +0.754    # # #   # #
  4   +0.508 -1.105 +0.611 +2.562 -1.724 -1.193    # O # # O O
  5   +0.715 +1.017 +0.755 -0.284 -1.175 +1.185    # # #   O #


The diagrams at the right show the pixels of the image thresholded at
values less than -0.5 (O), greater than +0.5 (#), and between -0.5 and
+0.5 (space).  For the second image, noise in the pixels has made the
symbol less certain (probability 0.843 for the correct symbol) than
for the first case (probability 0.999 for the correct symbol), and for
the third image, the correct symbol has lower probability (0.418) than
one of the incorrect symbols (0.582) - with all these probabilities
computed assuming the true generation model is known.

The igen program computes the performance on test cases when using the
true model, which is an upper limit on what can be accomplished when
learning a model from the training cases (unless one just is lucky).
Here is the summary:

  Error rate on test cases with true model: 0.081
  Average squared error for test cases with true model: 0.115
  Average log probability for test cases with true model: -0.201


A fully-connected Bayesian neural network model.


A convolutional Bayesian neural network model.


Fitting the models with gradient descent.
</pre>
</body>
</html>
